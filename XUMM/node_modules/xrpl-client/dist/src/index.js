"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrplClient = void 0;
const assert_1 = __importDefault(require("assert"));
const events_1 = require("events");
const debug_1 = require("debug");
const websocket_1 = require("websocket");
__exportStar(require("./types"), exports);
const log = debug_1.debug("xrplclient");
const logWarning = log.extend("warning");
const logMessage = log.extend("message");
const logNodeInfo = log.extend("node");
const connectAttemptTimeoutSeconds = 3;
const assumeOfflineAfterSeconds = 15;
const maxConnectionAttempts = null;
const feeCushion = 1.2;
const feeDropsDefault = 12;
const feeDropsMax = 3600;
class XrplClient extends events_1.EventEmitter {
    constructor(endpoint, options) {
        var _a;
        super();
        this.eventBus = new events_1.EventEmitter();
        this.closed = false;
        this.destroyed = false;
        this.uplinkReady = false;
        this.options = {
            connectAttemptTimeoutSeconds,
            assumeOfflineAfterSeconds,
            maxConnectionAttempts,
            feeDropsDefault,
            feeDropsMax,
        };
        this.callId = 0;
        this.pendingCalls = [];
        this.subscriptions = [];
        this.serverState = {
            validatedLedgers: "",
            reserveBase: null,
            reserveInc: null,
            latency: [],
            fee: [],
            connectAttempts: -1,
        };
        if (options) {
            Object.assign(this.options, options);
        }
        /**
         * Alive timer
         */
        let livelinessCheck;
        const alive = () => {
            var _a;
            // log('Start alive timer')
            clearTimeout(livelinessCheck);
            const seconds = Number(((_a = this === null || this === void 0 ? void 0 : this.options) === null || _a === void 0 ? void 0 : _a.assumeOfflineAfterSeconds) || assumeOfflineAfterSeconds) * 1000;
            livelinessCheck = setTimeout(() => {
                var _a;
                // Only if the connection ever was online to begin with
                if (this.uplinkReady) {
                    logWarning(`Conn. TIMEOUT, no ledger for ${seconds} sec.`);
                    try {
                        (_a = this.connection) === null || _a === void 0 ? void 0 : _a.close();
                    }
                    catch (e) { }
                }
            }, seconds);
        };
        alive();
        const reconnectTime = () => {
            var _a, _b;
            let factor = 1;
            const attempts = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.maxConnectionAttempts) || maxConnectionAttempts;
            if (attempts) {
                factor =
                    ((((_b = this.options) === null || _b === void 0 ? void 0 : _b.connectAttemptTimeoutSeconds) ||
                        connectAttemptTimeoutSeconds) -
                        1) /
                        (attempts - 1);
            }
            const reconnectSeconds = Math.max(1.5, (this.serverState.connectAttempts + 1) * factor);
            return reconnectSeconds;
        };
        this.endpoints = [];
        if (endpoint) {
            this.endpoints = [
                ...new Set(Array.isArray(endpoint) ? endpoint : [endpoint]),
            ]
                .map((uplink) => uplink.trim())
                .filter((uplink) => uplink.match(/^ws[s]{0,1}:\/\//));
        }
        if (this.endpoints.length < 1) {
            this.endpoints = [
                "wss://xrplcluster.com",
                "wss://xrpl.link",
                "wss://s2.ripple.com",
            ];
            logWarning("No valid WebSocket endpoint(s) specified, falling back to defaults", this.endpoints);
        }
        this.endpoint = this.endpoints[0].trim();
        if (this.endpoints.length > 1 && !((_a = this.options) === null || _a === void 0 ? void 0 : _a.maxConnectionAttempts)) {
            log(`Multiple endpoints (${this.endpoints.length}) and no maxConnection attempts, set (3)`);
            Object.assign(this.options, { maxConnectionAttempts: 3 });
        }
        log(`Initialized xrpld WebSocket Client`);
        this.on("ledger", () => {
            connectionReady();
            alive();
        });
        const ignore = () => { };
        /**
         * Important one
         */
        const connectionReady = () => {
            if (!this.uplinkReady) {
                this.serverState.connectAttempts = 0;
                logNodeInfo("Connection ready, fire events");
                this.uplinkReady = true;
                this.eventBus.emit("flush");
                this.emit("online");
                this.emit("state", this.getState());
            }
        };
        /**
         * WebSocket client event handlers
         */
        const WsOpen = () => {
            /**
             * We're firing two commands when we're connected
             */
            if (!this.closed && this.connection.readyState === websocket_1.w3cwebsocket.OPEN) {
                log("Connection opened :)");
                /**
                 * XRPL Cluster state
                 */
                if (this.endpoint.match(/^wss:\/\/(xrplcluster\.com|xrpl\.link|xrpl\.ws)/)) {
                    try {
                        this.connection.send(JSON.stringify({ __api: "state", origin: "xrpl-client@js/ts" }));
                    }
                    catch (e) { }
                }
                /**
                 * Mandatory messages on connect
                 */
                this.send({
                    id: "_WsClient_Internal_Subscription",
                    command: "subscribe",
                    streams: ["ledger"],
                }, { sendIfNotReady: true, noReplayAfterReconnect: true }).then(ignore, ignore);
                this.send({
                    id: "_WsClient_Internal_ServerInfo@" + Number(new Date()),
                    command: "server_info",
                }, { sendIfNotReady: true, noReplayAfterReconnect: true }).then(() => {
                    connectionReady();
                }, ignore);
            }
            else {
                try {
                    this.connection.close();
                }
                catch (e) {
                    // If timing: came online after close: kill
                }
            }
        };
        const WsClose = (event) => {
            this.emit("close");
            this.emit("state", this.getState());
            if (this.uplinkReady) {
                // Was online
                this.emit("offline");
                // Was online, so start a new cycle instead of trying the next node
                this.endpoint = this.endpoints[0];
            }
            this.uplinkReady = false;
            this.serverInfo = undefined;
            logWarning("Upstream/Websocket closed", event === null || event === void 0 ? void 0 : event.code, event === null || event === void 0 ? void 0 : event.reason);
            WsCleanup();
            if (!this.closed) {
                this.emit("retry");
                logWarning(`Not closed on purpose, reconnecting after ${reconnectTime()}...`);
                setTimeout(() => {
                    this.eventBus.emit("reconnect");
                }, reconnectTime() * 1000);
            }
            else {
                log("Closed on purpose, not reconnecting");
            }
        };
        const handleServerInfo = (message) => {
            var _a, _b, _c;
            if ((_a = message === null || message === void 0 ? void 0 : message.result) === null || _a === void 0 ? void 0 : _a.info) {
                const serverInfo = message;
                if (!this.serverInfo) {
                    logNodeInfo("Connected, server_info:", {
                        pubkey_node: serverInfo.result.info.pubkey_node,
                        build_version: serverInfo.result.info.build_version,
                        complete_ledgers: serverInfo.result.info.complete_ledgers,
                    });
                }
                const msRoundTrip = Number(new Date()) -
                    Number(String((message === null || message === void 0 ? void 0 : message.id) || "")
                        .split("@")
                        .reverse()[0]);
                if (msRoundTrip) {
                    this.serverState.latency.push({
                        moment: new Date(),
                        value: msRoundTrip,
                    });
                    this.serverState.latency.splice(0, this.serverState.latency.length - 10);
                }
                const fee = Number(((_c = (_b = serverInfo.result.info) === null || _b === void 0 ? void 0 : _b.validated_ledger) === null || _c === void 0 ? void 0 : _c.base_fee_xrp) ||
                    (this.options.feeDropsDefault || feeDropsDefault) / 1000000) *
                    1000000 *
                    feeCushion;
                if (fee && fee <= (this.options.feeDropsMax || feeDropsMax)) {
                    this.serverState.fee.push({
                        moment: new Date(),
                        value: fee,
                    });
                    this.serverState.fee.splice(0, this.serverState.fee.length - 5);
                }
                this.serverInfo = serverInfo;
            }
        };
        const handleAsyncWsMessage = (message) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            if (((_a = message === null || message === void 0 ? void 0 : message.id) === null || _a === void 0 ? void 0 : _a._Request) !== "_WsClient_Internal_Subscription") {
                let matchingSubscription;
                if ((_b = message === null || message === void 0 ? void 0 : message.id) === null || _b === void 0 ? void 0 : _b._WsClient) {
                    const _matching = this.subscriptions.filter((s) => { var _a; return s.id === ((_a = message === null || message === void 0 ? void 0 : message.id) === null || _a === void 0 ? void 0 : _a._WsClient); });
                    if (_matching.length > 0) {
                        matchingSubscription = _matching[0];
                        matchingSubscription.promiseCallables.resolve(Object.assign(message, {
                            id: (_c = message === null || message === void 0 ? void 0 : message.id) === null || _c === void 0 ? void 0 : _c._Request,
                        }));
                    }
                }
                this.emit("message", message);
                if ((message === null || message === void 0 ? void 0 : message.type) === "ledgerClosed" && typeof (message === null || message === void 0 ? void 0 : message.validated_ledgers) === "string") {
                    logMessage("Async", message.type);
                    Object.assign(this.serverState, {
                        validatedLedgers: message.validated_ledgers,
                        reserveBase: Number(message === null || message === void 0 ? void 0 : message.reserve_base) / 1000000 || null,
                        reserveInc: Number(message === null || message === void 0 ? void 0 : message.reserve_inc) / 1000000 || null,
                    });
                    this.emit("ledger", message);
                    /**
                     * Always request a server_info for a received ledger as well
                     */
                    this.send({
                        id: "_WsClient_Internal_ServerInfo@" + Number(new Date()),
                        command: "server_info",
                    }).then(ignore, ignore);
                }
                else if ((message === null || message === void 0 ? void 0 : message.type) === "path_find") {
                    logMessage("Async", message.type);
                    this.emit("path", message);
                }
                else if ((message === null || message === void 0 ? void 0 : message.type) === "transaction") {
                    logMessage("Async", message.type);
                    this.emit("transaction", message);
                }
                else if (message === null || message === void 0 ? void 0 : message.validation_public_key) {
                    logMessage("Async", "validation");
                    this.emit("validation", message);
                }
                else {
                    if (((_d = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _d === void 0 ? void 0 : _d.command) === "path_find") {
                        logMessage("Async", (_e = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _e === void 0 ? void 0 : _e.command);
                        this.emit("path", message);
                    }
                    else if (((_f = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _f === void 0 ? void 0 : _f.command) === "subscribe" &&
                        Array.isArray((_g = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _g === void 0 ? void 0 : _g.streams) &&
                        ((_h = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _h === void 0 ? void 0 : _h.streams.indexOf("ledger")) > -1) {
                        logMessage("Async", "subscription:ledger");
                        this.emit("ledger", (message === null || message === void 0 ? void 0 : message.result) ? message.result : message);
                    }
                    else if (matchingSubscription) {
                        // Don't log `Unknown` as we know this
                    }
                    else {
                        const isInternal = ((_j = message === null || message === void 0 ? void 0 : message.id) === null || _j === void 0 ? void 0 : _j._Request) &&
                            String(message.id._Request).match(/^_WsClient_Internal/);
                        if (!isInternal) {
                            try {
                                const clusterInfo = message;
                                if ((clusterInfo === null || clusterInfo === void 0 ? void 0 : clusterInfo.type) === "PROXY") {
                                    this.clusterInfo_ = clusterInfo;
                                    this.emit("clusterinfo", this.clusterInfo_);
                                    return;
                                }
                            }
                            catch (e) { }
                            logMessage(`Handle <UNKNOWN> Async Message`, {
                                internalId: (_k = message === null || message === void 0 ? void 0 : message.id) === null || _k === void 0 ? void 0 : _k._WsClient,
                                matchingSubscription,
                                type: message === null || message === void 0 ? void 0 : message.type,
                                message,
                            });
                        }
                    }
                }
            }
        };
        const WsMessage = (message) => {
            var _a, _b, _c, _d, _e, _f;
            try {
                assert_1.default(typeof message.data === "string", "Unexpected incoming WebSocket message data type");
                const messageJson = JSON.parse(message.data);
                this.lastContact = new Date();
                if ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient) {
                    // Got response on a command, process accordingly
                    const matchingSubscription = this.subscriptions.filter((call) => {
                        var _a;
                        return call.id === ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient);
                    });
                    const matchingCall = this.pendingCalls.filter((call) => {
                        var _a;
                        return call.id === ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient);
                    });
                    if (matchingSubscription.length === 1) {
                        handleAsyncWsMessage(messageJson);
                    }
                    else if (matchingCall.length === 1) {
                        const internalServerInfoCall = String(((_d = (_c = (_b = matchingCall[0]) === null || _b === void 0 ? void 0 : _b.request) === null || _c === void 0 ? void 0 : _c.id) === null || _d === void 0 ? void 0 : _d._Request) || "").split("@")[0] === "_WsClient_Internal_ServerInfo";
                        Object.assign(messageJson, {
                            id: (_e = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _e === void 0 ? void 0 : _e._Request,
                        });
                        if (((_f = matchingCall[0].sendOptions) === null || _f === void 0 ? void 0 : _f.timeoutSeconds) &&
                            matchingCall[0].timeout) {
                            clearTimeout(matchingCall[0].timeout);
                        }
                        matchingCall[0].promiseCallables.resolve((messageJson === null || messageJson === void 0 ? void 0 : messageJson.result) || messageJson);
                        this.pendingCalls.splice(this.pendingCalls.indexOf(matchingCall[0]), 1);
                        if (!internalServerInfoCall) {
                            log("Â» Pending Call Length", this.pendingCalls.length);
                        }
                        else {
                            handleServerInfo(messageJson);
                        }
                    }
                    else {
                        // Subscription/path finding ack
                        handleAsyncWsMessage(messageJson);
                    }
                }
                else {
                    // Subscription/path finding followup
                    handleAsyncWsMessage(messageJson);
                }
            }
            catch (e) {
                logWarning("Uplink response: parse error", e.message);
            }
        };
        const WsError = (error) => {
            logWarning("Upstream/Websocket error");
        };
        const applyCallTimeout = (call) => {
            var _a;
            if (((_a = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _a === void 0 ? void 0 : _a.timeoutSeconds) && !(call === null || call === void 0 ? void 0 : call.timeout)) {
                Object.assign(call, {
                    timeout: setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        var _b;
                        const didTimeout = (yield Promise.race([
                            call.promise,
                            Promise.resolve("_WsClient_Internal_CallResolved"),
                        ])) === "_WsClient_Internal_CallResolved";
                        if (didTimeout) {
                            call.promiseCallables.reject(new Error(`Call timeout after ${(_b = call.sendOptions) === null || _b === void 0 ? void 0 : _b.timeoutSeconds} seconds`));
                        }
                    }), Number(call.sendOptions.timeoutSeconds) * 1000),
                });
            }
        };
        const process = (call) => {
            var _a, _b, _c;
            // const isSubscription = call.request.command === "subscribe";
            if (String(((_b = (_a = call === null || call === void 0 ? void 0 : call.request) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b._Request) || "").split("@")[0] !==
                "_WsClient_Internal_ServerInfo") {
                log("  > Process call", call.id, call.request.command);
            }
            try {
                // log(call.request);
                this.connection.send(JSON.stringify(call.request));
                if ((_c = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _c === void 0 ? void 0 : _c.timeoutStartsWhenOnline) {
                    // logWarning("APPLY TIMEOUT ONLY AFTER GOING ONLINE");
                    applyCallTimeout(call);
                }
            }
            catch (e) {
                logWarning("Process (send to uplink) error", e.message);
            }
        };
        const call = (call) => {
            var _a, _b, _c, _d, _e;
            if (String(((_b = (_a = call === null || call === void 0 ? void 0 : call.request) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b._Request) || "").split("@")[0] !==
                "_WsClient_Internal_ServerInfo") {
                log(`Call ${call.id}: ${call.request.command}\n   > `, this.uplinkReady
                    ? "Uplink ready, pass immediately"
                    : ((_c = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _c === void 0 ? void 0 : _c.sendIfNotReady)
                        ? "Uplink not flagged as ready yet, but `sendIfNotReady` = true, so go ahead"
                        : "Uplink not ready, wait for flush");
            }
            if (!((_d = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _d === void 0 ? void 0 : _d.timeoutStartsWhenOnline)) {
                // logWarning("APPLY TIMEOUT NO MATTER ONLINE/OFFLINE STATE");
                applyCallTimeout(call);
            }
            if (this.uplinkReady || ((_e = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _e === void 0 ? void 0 : _e.sendIfNotReady)) {
                process(call);
            }
        };
        const flush = () => {
            /**
             * Flush all pending calls & subscriptions
             * to new uplink.
             */
            log("Connected, flushing pending calls & subscriptions");
            this.pendingCalls.forEach((call) => {
                process(call);
            });
            this.subscriptions.forEach((call) => {
                process(call);
            });
        };
        const reinstate = (options) => {
            assert_1.default(!this.destroyed, "Object is in destroyed state");
            log("Reinstating..., options:", options || {});
            if (options === null || options === void 0 ? void 0 : options.forceNextUplink) {
                this.uplinkReady = false; // Prevents going back to endpoint[0]
                clearTimeout(livelinessCheck);
                selectNextUplink();
            }
            else {
                this.closed = false;
                alive();
            }
            this.connection = connect();
        };
        const close = (error) => {
            log("Closing connection");
            this.emit("close");
            this.closed = true;
            try {
                this.connection.close();
            }
            catch (e) {
                //
            }
            clearTimeout(livelinessCheck);
            if (error) {
                this.emit("error", error);
            }
        };
        const destroy = (error) => {
            this.destroyed = true;
            close(error);
            WsCleanup();
            this.subscriptions.forEach((subscription) => {
                subscription.promiseCallables.reject(new Error("Class (connection) hard close requested"));
            });
            this.pendingCalls.forEach((call) => {
                call.promiseCallables.reject(new Error("Class (connection) hard close requested"));
            });
            this.eventBus.off("__WsClient_call", call);
            this.eventBus.off("__WsClient_destroy", destroy);
            this.eventBus.off("__WsClient_close", close);
            this.eventBus.off("__WsClient_reinstate", reinstate);
            this.eventBus.off("flush", flush);
            this.eventBus.off("reconnect", connect);
        };
        const WsCleanup = () => {
            log("Cleanup");
            this.connection.removeEventListener("open", WsOpen);
            this.connection.removeEventListener("message", WsMessage);
            this.connection.removeEventListener("error", WsError);
            this.connection.removeEventListener("close", WsClose);
        };
        const selectNextUplink = () => {
            const nextEndpointIndex = this.endpoints.indexOf(this.endpoint) + 1;
            logWarning("--- Current endpoint", this.endpoint);
            this.endpoint =
                this.endpoints[nextEndpointIndex >= this.endpoints.length ? 0 : nextEndpointIndex];
            logWarning("--- New endpoint", this.endpoint);
            this.serverState.connectAttempts = 0;
            this.emit("nodeswitch", this.endpoint);
            if (nextEndpointIndex >= this.endpoints.length) {
                this.emit("round");
            }
        };
        const connect = () => {
            var _a, _b, _c, _d, _e;
            try {
                this.connection.close();
            }
            catch (e) {
                //
            }
            log("Connecting", this.endpoint);
            this.serverState.connectAttempts++;
            if (this.options.maxConnectionAttempts &&
                Number(((_a = this.options) === null || _a === void 0 ? void 0 : _a.maxConnectionAttempts) || 1) > 1 &&
                this.serverState.connectAttempts >=
                    Number(((_b = this.options) === null || _b === void 0 ? void 0 : _b.maxConnectionAttempts) || 1)) {
                logNodeInfo("Too many connection attempts", this.serverState.connectAttempts, (_c = this.options) === null || _c === void 0 ? void 0 : _c.maxConnectionAttempts);
                log(this.endpoint, this.endpoints, this.endpoints.length, this.endpoints.indexOf(this.endpoint));
                if (this.endpoints.length > 1 &&
                    this.endpoints.indexOf(this.endpoint) > -1) {
                    logWarning("Multiple endpoints, max. connection attempts exceeded. Switch endpoint.");
                    selectNextUplink();
                }
                else {
                    logWarning("Only one valid endpoint, after the max. connection attempts: game over");
                    close(new Error("Max. connection attempts exceeded"));
                }
            }
            if (!this.closed) {
                const connection = new websocket_1.w3cwebsocket(this.endpoint, // url
                undefined, // protocols
                undefined, // origin
                Object.assign(((_d = this.options) === null || _d === void 0 ? void 0 : _d.httpHeaders) || {}, {
                    "user-agent": "xrpl-client@js/ts",
                }), // headers
                ((_e = this.options) === null || _e === void 0 ? void 0 : _e.httpRequestOptions) || {}, // requestOptions
                {
                    maxReceivedFrameSize: 0x80000000,
                    maxReceivedMessageSize: 0x200000000, // 8GB
                } // IClientConfig
                );
                // Prevent possible DNS resolve hang, and a custom
                // resolver sucks
                setTimeout(() => {
                    if (connection.readyState !== websocket_1.w3cwebsocket.OPEN) {
                        connection.close();
                    }
                }, reconnectTime() * 1000 - 1);
                connection.addEventListener("open", WsOpen);
                connection.addEventListener("message", WsMessage);
                connection.addEventListener("error", WsError);
                connection.addEventListener("close", WsClose);
                this.connection = connection;
            }
            return this.connection;
        };
        this.eventBus.on("__WsClient_call", call);
        this.eventBus.on("__WsClient_destroy", destroy);
        this.eventBus.on("__WsClient_close", close);
        this.eventBus.on("__WsClient_reinstate", reinstate);
        this.eventBus.on("flush", flush);
        this.eventBus.on("reconnect", connect);
        this.connection = connect();
    }
    ready() {
        return new Promise((resolve, reject) => {
            const state = this.getState();
            if (state.online &&
                state.secLastContact &&
                state.secLastContact < 10 &&
                state.ledger.last) {
                // We're good
                return resolve(this);
            }
            else {
                // Let's wait to make sure we're really connected
                this.on("ledger", () => {
                    resolve(this);
                });
            }
        });
    }
    send(call, sendOptions = {}) {
        var _a, _b, _c;
        assert_1.default(typeof call === "object" && call, "`send()`: expecting object containing `command`");
        assert_1.default(typeof call.command === "string", "`command` must be typeof string");
        this.callId++;
        const promiseCallables = {
            resolve: (arg) => { },
            reject: (arg) => { },
        };
        const promise = new Promise((resolve, reject) => {
            Object.assign(promiseCallables, { resolve, reject });
        });
        const pendingCall = {
            id: this.callId,
            request: Object.assign(call, {
                id: {
                    _WsClient: this.callId,
                    _Request: call === null || call === void 0 ? void 0 : call.id,
                },
                command: call.command.toLowerCase().trim(),
            }),
            promise,
            promiseCallables,
            sendOptions,
        };
        if (this.destroyed) {
            promiseCallables.reject(new Error("Client in destroyed state"));
            return promise;
        }
        const isSubscription = (pendingCall.request.command === "subscribe" ||
            pendingCall.request.command === "unsubscribe" ||
            pendingCall.request.command === "path_find") &&
            !(sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions.noReplayAfterReconnect);
        if (((_a = pendingCall.request) === null || _a === void 0 ? void 0 : _a.command) === "unsubscribe" &&
            Array.isArray((_b = pendingCall.request) === null || _b === void 0 ? void 0 : _b.streams) &&
            ((_c = pendingCall.request) === null || _c === void 0 ? void 0 : _c.streams.indexOf("ledger")) > -1) {
            pendingCall.request.streams.splice(pendingCall.request.streams.indexOf("ledger"), 1);
            if (pendingCall.request.streams.length === 0 &&
                Object.keys(pendingCall.request).filter((key) => key !== "id" && key !== "streams" && key !== "command").length === 0) {
                // Unsubscribing (just) streams
                return Promise.reject(new Error("Unsubscribing from (just) the ledger stream is not allowed"));
            }
        }
        if (String((call === null || call === void 0 ? void 0 : call.id) || "").split("@")[0] !== "_WsClient_Internal_ServerInfo") {
            this[isSubscription ? "subscriptions" : "pendingCalls"].push(pendingCall);
        }
        this.eventBus.emit("__WsClient_call", pendingCall);
        return promise;
    }
    getState() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const ledgerCount = this.serverState.validatedLedgers
            .split(",")
            .map((m) => {
            const Range = m.split("-");
            return Range.length > 1 ? parseInt(Range[1]) - parseInt(Range[0]) : 1;
        })
            .reduce((a, b) => a + b, 0);
        return {
            online: this.uplinkReady &&
                !this.closed &&
                this.connection.readyState === websocket_1.w3cwebsocket.OPEN,
            latencyMs: {
                last: this.serverState.latency
                    .slice(-1)
                    .map((latencyRecord) => latencyRecord.value)[0] || null,
                avg: this.serverState.latency
                    .map((latencyRecord) => latencyRecord.value)
                    .reduce((a, b) => a + b, 0) / this.serverState.latency.length ||
                    null,
                secAgo: Number(new Date()) / 1000 -
                    this.serverState.latency
                        .slice(-1)
                        .map((latencyRecord) => Number(latencyRecord.moment) / 1000)[0] ||
                    null,
            },
            server: {
                version: ((_c = (_b = (_a = this.serverInfo) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b.info) === null || _c === void 0 ? void 0 : _c.build_version) || "",
                uptime: ((_f = (_e = (_d = this.serverInfo) === null || _d === void 0 ? void 0 : _d.result) === null || _e === void 0 ? void 0 : _e.info) === null || _f === void 0 ? void 0 : _f.uptime) || 0,
                publicKey: ((_j = (_h = (_g = this.serverInfo) === null || _g === void 0 ? void 0 : _g.result) === null || _h === void 0 ? void 0 : _h.info) === null || _j === void 0 ? void 0 : _j.pubkey_node) || "",
                uri: this.endpoint,
            },
            ledger: {
                last: Number(this.serverState.validatedLedgers
                    .split(",")
                    .reverse()[0]
                    .split("-")
                    .reverse()[0]),
                validated: this.serverState.validatedLedgers,
                count: this.serverState.validatedLedgers === "" ? 0 : ledgerCount,
            },
            fee: {
                last: this.serverState.fee
                    .slice(-1)
                    .map((feeRecord) => feeRecord.value)[0] ||
                    this.options.feeDropsDefault ||
                    feeDropsDefault,
                avg: this.serverState.fee
                    .map((feeRecord) => feeRecord.value)
                    .reduce((a, b) => a + b, 0) / this.serverState.fee.length ||
                    this.options.feeDropsDefault ||
                    feeDropsDefault,
                secAgo: Number(new Date()) / 1000 -
                    this.serverState.fee
                        .slice(-1)
                        .map((feeRecord) => Number(feeRecord.moment) / 1000)[0] || null,
            },
            reserve: {
                base: this.serverState.reserveBase,
                owner: this.serverState.reserveInc,
            },
            secLastContact: this.lastContact
                ? Number(new Date()) / 1000 - Number(this.lastContact) / 1000
                : null,
        };
    }
    close() {
        // assert(!this.closed, "Object already in closed state");
        log(`> CLOSE`);
        this.eventBus.emit("__WsClient_close");
    }
    reinstate(options) {
        // assert(!this.closed, "Object already reinstated state");
        log(`> REINSTATE`);
        this.eventBus.emit("__WsClient_reinstate", options);
    }
    destroy() {
        // assert(!this.closed, "Object already in destroyed state");
        log(`> DESTROY`);
        this.eventBus.emit("__WsClient_destroy");
    }
    clusterInfo() {
        return new Promise((resolve, reject) => {
            if (this.clusterInfo_) {
                // We're good
                return resolve(this.clusterInfo_);
            }
            else {
                // Let's wait to make sure we're really connected
                this.on("clusterinfo", (info) => {
                    resolve(info);
                });
            }
        });
    }
}
exports.XrplClient = XrplClient;
